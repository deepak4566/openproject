# This capsulates the validation of a requested redirect URL.
#
class RedirectPolicy
  attr_reader validated_redirect_url: untyped

  attr_reader request: untyped

  def initialize: (untyped requested_url, hostname: untyped, default: untyped, ?return_escaped: bool) -> void

  #
  # Performs all validations for the requested URL
  def valid?: () -> (false | untyped)

  #
  # Return a valid redirect URI.
  # If the validation check on the current back URL apply
  def redirect_url: () -> untyped

  private

  #
  # Preprocesses the requested redirect URL.
  # - Escapes it when necessary
  # - Tries to parse it
  # - Escapes the redirect URL when requested so.
  def preprocess: (untyped requested) -> untyped

  #
  # Postprocesses the validated URL
  def postprocess: (untyped redirect_url) -> untyped

  #
  # Avoid paths with references to parent paths
  def no_upper_levels: () -> untyped

  #
  # Require URLs to contain a path slash.
  # This will always be the case for parsed URLs unless
  # +URI.parse('@foo.bar')+ or a non-root relative URL  +URI.parse('foo')+
  def path_has_slash: () -> untyped

  #
  # do not redirect user to another host (even protocol relative urls have the host set)
  # whenever a host is set it must match the request's host
  def same_host: () -> untyped

  #
  # Avoid redirect URLs to specific locations, such as login page
  def path_not_blacklisted: () -> untyped

  #
  # Requires the redirect URL to reside inside the relative root, when given.
  def matches_relative_root: () -> untyped
end
