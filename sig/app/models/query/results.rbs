class ::Query::Results
  include ::Query::Results::GroupBy

  include ::Query::Results::Sums

  include Redmine::I18n

  attr_accessor query: untyped

  def initialize: (untyped query) -> void

  # Returns the work packages adhering to the filters and ordered by the provided criteria (grouping and sorting)
  def work_packages: () -> untyped

  private

  def sorted_work_packages_matching_the_filters_today: () -> untyped

  def sorted_work_packages_matching_the_filters_at_any_of_the_given_timestamps: () -> untyped

  # For filtering on historic data, this returns the work packages
  # matching the filters for any of the timestamps provided in the query.
  # Visibility (permissions) are checked at all of the times. In combination with the `or`
  # concatenation that means that a user has to have no permission to see a work package
  # at any of the timestamps. This has to be used with care. Callers will have to
  # ensure to not reveal information.
  def work_packages_matching_the_filters_at_any_of_the_given_timestamps: () -> untyped

  # Returns an active-record relation that applies the filters to find the matching
  # work packages.
  #
  # This can be chained with `.at_timestamp(...)` in order to search historic data
  # as required for the baseline-comparison feature.
  #
  # https://community.openproject.org/projects/openproject/work_packages/26448
  #
  def filtered_work_packages: () -> untyped

  def filtered_work_packages_matching_the_filters_today: () -> untyped

  def sorted_work_packages: () -> untyped

  def order_option: () -> untyped

  def work_package_scope: () -> untyped

  def all_includes: () -> untyped

  def includes_for_columns: (untyped column_names) -> untyped

  def custom_field_column?: (untyped name) -> untyped

  #
  # Returns the columns that need to be included to allow:
  # * sorting
  # * grouping
  def include_columns: () -> untyped

  def sort_criteria_joins: () -> untyped

  def sort_criteria_array: () -> untyped

  def aliased_sorting_by_column_name: () -> untyped

  #
  # Returns the expanded association columns name
  def expand_association_columns: (untyped alias_name, untyped sortable, untyped columns_hash) -> untyped

  #
  # Returns a single expanded association column name
  def expand_association_column: (untyped column, untyped alias_name) -> (untyped | ::String)

  #
  # Return the columns hash for a given association
  # If the association is nil, then return the WorkPackage.columns_hash
  def columns_hash_for: (?untyped? association) -> untyped

  #
  # Return the case insensitive version for columns with a string type
  def case_insensitive_condition: (untyped column_key, untyped condition, untyped columns_hash) -> (::String | untyped)

  #
  # Find the custom field type based on the column key
  def custom_field_type: (untyped column_key) -> untyped

  # To avoid naming conflicts, joined tables are aliased if they are joined
  # more than once. Here, joining tables that are referenced by multiple
  # columns are of particular interest.
  #
  # Mirroring the way AR creates aliases for included/joined tables: Normally,
  # included/joined associations are not aliased and as such, they simply use
  # the table name. But if an association is joined/included that relies on a
  # table which an already joined/included association also relies upon, that
  # name is already taken in the DB query. Therefore, the #alias_candidate
  # method is used which will concatenate the pluralized association name with
  # the table name the association is defined for.
  #
  # There is no handling for cases when the same association is joined/included
  # multiple times as the rest of the code should prevent that.
  def include_aliases: () -> untyped

  def reflection_includes: () -> untyped

  def reflection_alias: (untyped reflection, untyped count) -> untyped

  def all_filter_includes: (untyped query) -> untyped

  def all_filter_joins: () -> untyped

  def filter_merges: () -> untyped

  def clean_symbol_list: (untyped list) -> untyped
end
