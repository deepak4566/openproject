module WorkPackages::Scopes
  module ForScheduling
    extend ActiveSupport::Concern

    # Fetches all work packages that need to be evaluated for eventual
    # rescheduling after a related (i.e. follows/precedes and hierarchy) work
    # package is modified or created.
    #
    # The SQL relies on a recursive CTE which will fetch all work packages
    # that are connected to the rescheduled work packages via relations
    # (follows/precedes and/or hierarchy) either directly or transitively. It
    # will do so by increasing the relation path length one at a time and will
    # stop on that path if the work package evaluated to be added is either:
    #
    #   * itself scheduled manually
    #   * having all of it's children scheduled manually
    #
    # The children themselves are scheduled manually if all of their children
    # are scheduled manually which repeats itself down to the leaf work
    # packages. So another way of putting it, and that is how the sql
    # statement works, is that a work package is considered to be scheduled
    # manually if *all* of its descendants are scheduled manually.
    #
    # For example in case of the hierarchy:
    #   A and B <- hierarchy (C is parent of both A and B) - C <- hierarchy - D
    # * A and B are work packages
    # * C is parent of A and B
    # * D is parent of C
    #
    # * If A and B are both scheduled manually, then C is also scheduled
    #   manually and so is D.
    # * If only A is scheduled manually, then B, C and D are scheduled
    #   automatically.
    # * If only C is scheduled manually, then D is still scheduled
    #   automatically since A and B are scheduled automatically.
    #
    # The recursion will of course also stop if no more work packages can be
    # added.
    #
    # The work packages can either be connected via a follows relationship, a
    # hierarchy relationship or a combination of both.
    #
    # E.g. in a graph of
    #   A  <- follows - B <- hierarchy (C is parent of B) - C <- follows D
    # * B is a successor of A
    # * C is parent of B
    # * D is successor of C
    #
    # When considering A, D would also be subject to reschedule.
    #
    # At least for hierarchical relationships, we need to follow the
    # relationship in both directions.
    #
    # E.g. in a graph of
    #   A  <- follows - B - hierarchy (B is parent of C) -> C <- follows D
    # * B is successor of A
    # * B is parent of C
    # * D is successor of C
    #
    # When considering A, D would also be subject to reschedule.
    #
    # That possible switch in direction means that we cannot simply get all
    # possibly affected work packages by one SQL query which the DAG
    # implementation would have allowed us to do otherwise.
    #
    # Currently, we do not rely on DAG for increasing the path length at all.
    # We are still employing it in the check for whether all paths to the leaf
    # have a manually scheduled work package.
    #
    # A further improvement in performance might be reachable by also
    # employing DAG mechanisms to increase the path length.
    #
    # @param work_packages WorkPackage[] A set of work packages for which the
    #   set of related work packages that might be subject to reschedule is
    #   fetched.
    def for_scheduling: (untyped work_packages) -> untyped

    private

    # This recursive CTE fetches all work packages that are in a direct or
    # transitive follows and/or hierarchy relationship with the provided work
    # package.
    #
    # Hierarchy relationships are followed up as well as down (from and to)
    # but follows relations are only followed from the predecessor to the
    # successor (from_id to to_id).
    #
    # The CTE starts from the provided work packages and returns for each of
    # them:
    #
    #   * id: the id of the work package
    #   * manually: the information that the starting work package is not
    #     manually scheduled.
    #
    # Whether the starting work package is manually scheduled or in fact
    # automatically scheduled does make no difference but we need this
    # information later on.
    #
    # For each recursive step, we return all work packages that are directly
    # related to our current set of work packages by a hierarchy (up or down)
    # or follows relationship (only successors). For each such work package
    # the statement returns:
    #
    #   * id of the work package that is currently at the end of a path.
    #   * the flag indicating whether the added work package is automatically
    #     or manually scheduled. This also includes whether *all* of the added
    #     work package's descendants are automatically or manually scheduled.
    #
    # Paths whose ending work package is marked to be manually scheduled are
    # not joined with any more.
    def scheduling_paths_sql: (untyped work_packages) -> untyped
  end
end
