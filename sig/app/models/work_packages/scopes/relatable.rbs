module WorkPackages::Scopes
  module Relatable
    extend ActiveSupport::Concern

    # Returns all work packages which can become part of a new relation from or to the provided work package where the
    # new relation would receive the provided type (e.g. 'blocks').
    #
    # For most relation types, e.g. 'includes', the four following rules must be satisfied:
    # * Non circular: relations cannot form a circle, e.g. a -> b -> c -> a.
    # * Single relation: only one relation can be created between any two work packages. E.g. it is not possible to create
    #   two relations like this:
    #   * WP 1 ────follows────> WP 2
    #   * WP 1 ────includes────> WP 2
    #   The type of the relation is of no relevance for this constraint.
    # * Ancestor/descendant: relations cannot be drawn between ancestor and descendants. It is important to note though,
    #   that relations can be created between any two work packages within the same tree as long as they are not in a direct
    #   or transitive (e.g. parent of the parent or child of the child) ancestor/descendant relationship. So a relation between
    #   siblings is just as possible as one between aunt and nephew. Additionally, a transitive relationship which leaves the
    #   tree for any one hop, is exempt from that rule so it is possible to have:
    #                  WP parent ────┐
    #                    │         includes
    #                    │           │
    #                    │           v
    #                 hierarchy    other WP
    #                    │           │
    #                    │           │
    #                    v        includes
    #                  WP child <────┘
    # * No circles between trees: The ancestor/descendant chain is considered bidirectional when calculating relatability.
    #   This means that starting from the work package both the descendants as well as the ancestors are considered. That
    #   way, relations like
    #                  WP parent1 <────follows──── WP parent2
    #                    │                            │
    #                    │                            │
    #                 hierarchy                    hierarchy
    #                    │                            │
    #                    v                            v
    #                  WP child1 ────follows────> WP child2
    #   are prevented.
    #
    # For some of the relations, this has actual relevance (FOLLOWS, PRECEDES, PARENT because of scheduling) while for the
    # most, it is simply a question of semantics which is not manifested in code (all the other).
    #
    # For the sake of this scope, hierarchy relations (Relation::TYPE_PARENT and Relation::TYPE_CHILD) are also included
    # in the list of possible relation_types even though they are not stored in the same data structure. All
    # Relation::TYPE_* values can be provided even those that are not canonical, e.g. Relation::TYPE_PRECEDES.
    # The calculations for those relation types are then inverted and the canonical type is used, e.g. Relation::TYPE_FOLLOWS.
    #
    # There are a couple of exceptions and additions to the limitations outlined above for the following types:
    # * Relation::TYPE_RELATES: Since this is essentially undirected and does not carry a lot of semantic, the work packages
    #   are simply somehow related, such relations only follow the "single relation" rule (which includes their direct
    #   parent/children) and  none of the other.
    # * Relation::TYPE_PARENT: Since creating a new relationship will remove the old parent relationship, current ancestors
    #   (except the direct parent) are relatable to. Descendants however are not since that would create a circle.
    #   In addition to the existing hierarchy, the FOLLOWS relationships are taken into account. Predecessors and successors
    #   (FOLLOWS relationship) may also not be related to via a PARENT relation. However, parents and children of those
    #   predecessors/successors can be related to. But they still need to be considered in the code since they might be
    #   part of an almost completed circle which would be closed if a work package is added as a parent. E.g. in
    #                    WP4 <────follows──── WP3
    #                                          │
    #                                          │
    #                                       hierarchy
    #                                          │
    #                                          v
    #                                         WP2 <────follows──── WP1
    #   WP4 is not a valid parent candidate for WP1 since it would create the structure used as an example in
    #   "No circle for trees". However WP3 would be relatable to.
    #   Work packages related via follows/precedes to any descendant of a work package are exempt from being relatable right
    #   away as it would create a circle.
    # * Relation::TYPE_CHILD: The relation essentially follows the same rules, albeit inverted, as PARENT since it is
    #   the non canonical equivalent of it. Again, the parent relation of current children will be altered upon creating a new
    #   relation. Because of that, all descendants (as opposed to ancestors as is the case for PARENT) can be related to.
    #   The following in depth discussion focuses on the PARENT relation to walk through the special cases of the hierarchical
    #   relation. Whenever PARENT is mentioned, CHILD is also included.
    #
    # The implementation focuses on excluding candidates. It does so in two parts:
    #   * Excluding all work packages with which a direct relation already exist (with additions for PARENT relations).
    #   * Excluding work packages that are related transitively (following a path of direct relationships).
    #
    # The first is straightforward for all relation types except for PARENT relations. For that majority, whenever there is
    # a relation of any type except PARENT either to or from the work package queried for, it is excluded. For PARENT relations,
    # both the descendants of the queried for work package as well as the descendants of any directly related work packages are
    # excluded as well since creating a PARENT relationship to one such work package would result in a relation up or down the
    # hierarchy which violates the ancestor/descendant rule.
    #
    # The second exclusion of candidates is more complicated and also depends on the type of relation that is
    # queried for. It uses a CTE to recursively find all work packages with which a transitive relationship of interest based
    # on the rules outlined above exist.
    #
    # For most of the relation types, this includes work packages in the direction towards or away from the
    # work package to be related to the hierarchy (ancestors and descendants - not siblings and aunts).
    # Note that only one of the directions is of interest, which is the one opposite to the one that is queried for via the
    # type. This is to prevent a circle of relationships. For the 'related' type, only the ancestors and descendants are of
    # interest.
    #
    # For PARENT relationships both directions of FOLLOWS/PRECEDES need to be taken into account, and of course,
    # hierarchy relation are to be included as well. This prevents creating invalid relations in a structure like this:
    #
    #          WP4 <────follows──── WP3                                        WP6 <────follows──── WP7
    #                                │                                          │
    #                                │                                          │
    #                             hierarchy                                  hierarchy
    #                                │                                          │
    #                                v                                          v
    #                               WP2 <────follows────  WP1 <────follows──── WP5
    #
    # where creating a parent relation to both WP4 or WP7 would create a circle between trees.
    #
    # The necessity to follow both directions spans to the queried for work package as well as to its descendants.
    # However, once started from that origin, if the direction of the path is inverted all the work packages on the path
    # afterwards are valid targets and need not be followed up on:
    #
    #                               WP3 <────follows──── WP4     WP7 <────follows──── WP6
    #                                │                                                 │
    #                                │                                                 │
    #                             hierarchy                                         hierarchy
    #                                │                                                 │
    #                                v                                                 v
    #                               WP2 <────follows──────── WP1 <────────follows──── WP5
    #
    # In the example above, WP4 as well as WP7 (and for completeness sake WP3 as well as WP6) are valid relation targets,
    # and every work package related to those two would be as well.
    # It is also important to note, that existing ancestors are of no importance since this part of the structure will change.
    # Creating a parent relationship is destructive since there can only ever be one.
    #
    # The result is a blocklist which will include work packages that can not be related to. The list is not complete
    # as it will not include the work packages related by different relation types so those are added additionally. For the
    # PARENT relationship, work packages directly related to any of the descendants are added as well. Ancestors of predecessors
    # and successors, which needed to be followed are to be removed from the blocklist since they are valid targets.
    #
    # The CTE has the following columns:
    # * id - the id of the work packages currently related. This is the result of the CTE.
    # * from_(hierarchy/from_id/to_id) - booleans to prevent that the CTE returns back the path calculated in the previous
    #                                    iteration.
    # * includes_(from_relation/to_relation) - booleans about the direction (from_id -> to_id or to_id -> from_id) of the path
    #                                          (the relations followed).
    #                                          This is relevant for a queried for PARENT relation. In that case, relations need
    #                                          to be followed from the queried for work package (and its descendants) in both
    #                                          directions. But only the direction taken from that origin needs to be followed
    #                                          henceforth.
    # * includes_hierarchy - boolean indicating that the last relation taken was a hierarchy relation. For a queried for
    #                        PARENT relation, whenever that is the case, the work package is a valid relation target although
    #                        it appears in the CTE.
    def relatable: (untyped work_package, untyped relation_type) -> untyped

    def not_having_transitive_relation: (untyped work_package, untyped relation_type) -> untyped

    private

    def not_having_potential_tree_relation_parent: (untyped work_package) -> untyped

    def not_having_potential_tree_relation_child: (untyped work_package) -> untyped

    def non_relatable_paths_sql: (untyped work_package, untyped relation_type) -> untyped

    def non_recursive_relatable_values: (untyped work_package, untyped relation_type) -> untyped

    def joined_existing_connections: (untyped relation_type) -> untyped

    # rubocop:disable Metrics/PerceivedComplexity
    def existing_relation_of_type_lateral: (untyped relation_type, ?limit_direction: bool) -> untyped

    def existing_hierarchy_lateral: (?with_descendants: bool) -> untyped

    def blocklist_condition: (untyped relation_type) -> untyped

    def descendant_or_self_ids_of: (untyped work_packages) -> untyped

    def ancestor_or_self_ids_of: (untyped work_packages) -> untyped
  end
end
