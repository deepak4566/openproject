class Report::SqlStatement
  class Union
    attr_accessor first: untyped

    attr_accessor second: untyped

    attr_accessor as: untyped

    def initialize: (untyped first, untyped second, ?untyped? as) -> void

    def to_s: () -> ::String

    def each_subselect: () { (untyped) -> untyped } -> untyped

    def gsub: (*untyped) ?{ () -> untyped } -> untyped
  end

  include Report::QueryUtils

  #
  # Describes the query. This may be used in a sql-comment later.
  attr_accessor desc: untyped

  #
  # Generates new SqlStatement.
  #
  # @param [String, #to_s] table Table name (or subselect) for from part.
  def initialize: (untyped table, ?::String desc) -> void

  #
  # Creates a uninon of the caller and the callee.
  #
  # @param [Report::SqlStatement] other Second part of the union
  # @return [String] The sql query.
  def union: (untyped other, ?untyped? as) -> untyped

  #
  # Adds sum(..) part to select.
  #
  # @param [#to_s] field Name of the field to aggregate on
  # @param [#to_s] name Name of the result (defaults to sum)
  def sum: (untyped field, ?::Symbol name, ?::Symbol type) -> untyped

  #
  # Adds count(..) part to select.
  #
  # @param [#to_s] field Name of the field to aggregate on (defaults to *)
  # @param [#to_s] name Name of the result (defaults to sum)
  def count: (?::String field, ?::Symbol name) -> untyped

  #
  # Generates the SQL query.
  # Code looks ugly in exchange for pretty output (so one does unterstand those).
  #
  # @return [String] The query
  def to_s: () -> untyped

  #
  # @overload from
  #   Reads the from part.
  #   @return [#to_s] From part
  # @overload from(table)
  #   Sets the from part.
  #   @param [#to_s] table
  #   @param [#to_s] From part
  def from: (?untyped? table) -> untyped

  #
  # Where conditions. Will be joined together by AND.
  #
  # @overload where
  #   Reads the where part
  #   @return [Array<#to_s>] Where clauses
  # @overload where(fields)
  #   Adds condition to where clause
  #   @param [Array, Hash, String] fields Parameters passed to sanitize_sql_for_conditions.
  # @see Report::QueryUtils#sanitize_sql_for_conditions
  def where: (?untyped? fields) -> untyped

  #
  # @return [Array<String>] List of table joins
  def joins: () -> untyped

  #
  # Adds an "left outer join" (guessing field names) to #joins.
  #
  # @overload join(name)
  #   @param [Symbol, String] name Singular table name to join with, will join plural from on table.id = table_id
  # @overload join(model)
  #   @param [#table_name, #model_name] model ActiveRecord model to join with
  # @overload join(hash)
  #   @param [Hash<#to_s => #to_s>] hash Key is singular table name to join with, value is field to join on
  # @overload join(*list)
  #   @param [Array<String,Symbol,Array>] list Will generate join entries (according to guessings described above)
  # @see #joins
  def join: (*untyped list) -> untyped

  def default_select: (?untyped? value) -> untyped

  #
  # @overload select
  #   @return [Array<String>] All fields/statements for select part
  #
  # @overload select(*fields)
  #   Adds fields to select query.
  #   @example
  #     SqlStatement.new.select(some_sql_statement) # [some_sql_statement.to_s]
  #     SqlStatement.new.select("sum(foo)")         # ["sum(foo)"]
  #     SqlStatement.new.select(:a).select(:b)      # ["a", "b"]
  #     SqlStatement.new.select(:bar => :foo)       # ["foo as bar"]
  #     SqlStatement.new.select(:bar => nil)        # ["NULL as bar"]
  #   @param [Array, Hash, String, Symbol, SqlStatement] fields Fields to add to select part
  #   @return [Array<String>] All fields/statements for select part
  def select: (*untyped fields) -> untyped

  def unselect: (*untyped fields) -> untyped

  def never_select: (*untyped fields) -> untyped

  #
  # Return the names which have been bound through select statements
  # @return [Array<String>] All fields for select part
  def selects: () -> untyped

  #
  # @overload group_by
  #   @return [Array<String>] All fields/statements for group by part
  #
  # @overload group(*fields)
  #   Adds fields to group by query
  #   @param [Array, String, Symbol] fields Fields to add
  def group_by: (*untyped fields) -> untyped

  def group_not_by: (*untyped fields) -> untyped

  def never_group_by: (*untyped fields) -> untyped

  #
  # @return [TrueClass, FalseClass] Whether or not to add a group by part.
  def group_by?: () -> untyped

  def inspect: () -> ::String

  def gsub: (*untyped) ?{ () -> untyped } -> untyped
end
