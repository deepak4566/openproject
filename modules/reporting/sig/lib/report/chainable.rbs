# Provides convenience layer and logic shared between GroupBy::Base and Filter::Base.
# Implements a double linked list (FIXME: is that the correct term?).
module Report
  class Chainable
    include Enumerable

    include Report::QueryUtils

    extend Report::InheritedAttribute

    extend Forwardable

    def self.accepts_property: (*untyped list) -> untyped

    def self.chain_list: (*untyped list) -> untyped

    def self.base?: () -> untyped

    def self.base: () -> (self | untyped)

    def self.from_base: () { () -> untyped } -> untyped

    def self.available: () -> untyped

    def self.register: (untyped label) -> untyped

    def self.table_joins: () -> untyped

    def self.table_from: (untyped value) -> untyped

    def self.join_table: (*untyped args) -> untyped

    def self.underscore_name: () -> untyped

    def self.put_sql_table_names: (?::Hash[untyped, untyped] table_prefix_placement) -> untyped

    #
    # The given block is called when a new chain is created for a report.
    # The query will be given to the block as a parameter.
    # Example:
    # initialize_query_with { |query| query.filter Report::Filter::City, :operators => '=', :values => 'Berlin, da great City' }
    def self.initialize_query_with: () { () -> untyped } -> untyped

    def self.cache_key: () -> untyped

    def self.label: () -> "Translation needed"

    alias self.inherited_attributes self.inherited_attribute

    alias self.accepts_properties self.accepts_property

    attr_accessor parent: untyped

    attr_accessor child: untyped

    attr_accessor type: untyped

    def each: () { (untyped) -> untyped } -> untyped

    def row?: () -> untyped

    def column?: () -> untyped

    def group_by?: () -> untyped

    def to_a: () -> untyped

    def top: () -> (self | untyped)

    def top?: () -> untyped

    def bottom?: () -> untyped

    def bottom: () -> (self | untyped)

    def initialize: (?untyped? child, ?::Hash[untyped, untyped] options) -> void

    def compute_to_a: () -> untyped

    def to_s: () -> untyped

    def serialize: () -> ::Array[untyped]

    def move_down: () -> untyped

    #
    # Reorder given elements of a doubly linked list to follow the lists order.
    # Don't use this for evil. Assumes there are no elements inbetween, does
    # not touch the first element's parent and the last element's child.
    # Does not touch elements not part of the list.
    #
    # @param [Array] *list Part of the linked list
    def reorder: (*untyped list) -> untyped

    def chain_collect: (untyped name, *untyped args) { () -> untyped } -> untyped

    # See #chain_collect
    def subchain_collect: (untyped name, *untyped args) { () -> untyped } -> untyped

    # overwrite in subclass to maintain constisten state
    # ie automatically turning
    #   FilterFoo.new(GroupByFoo.new(FilterBar.new))
    # into
    #   GroupByFoo.new(FilterFoo.new(FilterBar.new))
    # Returning false will make the
    def correct_position?: () -> true

    def clear: () -> untyped

    def result: () -> untyped

    def compute_result: () -> untyped

    def cached: (*untyped args) -> untyped

    def sql_statement: () -> untyped

    def self.field: () -> untyped

    def display?: () -> untyped

    def self.display!: () -> untyped

    def self.display?: () -> untyped

    def self.dont_display!: () -> untyped

    def self.selectable!: () -> untyped

    def self.selectable?: () -> untyped

    def self.not_selectable!: () -> untyped

    # Extra options this chainable accepts that are not defined in accepted_properties
    def self.extra_options: (*untyped symbols) -> untyped

    # This chainable type can only ever occur once in a chain
    def self.singleton: () -> untyped

    def self.last_table: () -> untyped

    def self.table_name: (?untyped? value) -> untyped

    def with_table: (untyped fields) -> untyped

    def mapping: () -> untyped

    def self.mapping: (untyped value) -> untyped

    def self.mapping_for: (untyped field) -> untyped
  end
end
