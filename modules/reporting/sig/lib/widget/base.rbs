module ::Widget
  class Base < Widget::ReportingWidget
    attr_reader engine: untyped

    attr_reader output: untyped

    attr_accessor request: untyped

    #
    # Deactivate caching for certain widgets. If called on Widget::Base,
    # caching is deactivated globally
    def self.dont_cache!: () -> untyped

    #
    # Query whether this widget class should be cached.
    def self.dont_cache?: () -> untyped

    def initialize: (untyped query) -> void

    #
    # Write a string to the canvas. The string is marked as html_safe.
    # This will write twice, if @cache_output is set.
    def write: (untyped str) -> untyped

    #
    # Render this widget. Abstract method. Needs to call #write at least once
    def render: () -> untyped

    #
    # Render this widget, passing options.
    # Available options:
    #   :to => canvas - The canvas (streaming or otherwise) to render to. Has to respond to #write
    def render_with_options: (?::Hash[untyped, untyped] options) { () -> untyped } -> untyped

    def cache_key: () -> untyped

    def cached?: () -> untyped

    private

    def cache?: () -> untyped

    #
    # Render this widget or serve it from cache
    def render_with_cache: (?::Hash[untyped, untyped] _options) { () -> untyped } -> untyped

    #
    # Set the canvas. If the canvas object isn't a string (e.g. cannot be cached easily),
    # a @cache_output String is created, that will mirror what is being written to the canvas.
    def set_canvas: (untyped canvas) -> untyped
  end
end
